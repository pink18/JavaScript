### 语句

#### 条件语句

1: if else  

- 应用：在不同条件下输出不同结果时候。 难点【如何根据条件写表达式】 
- 代码块中变量  是【全局变量】
- 如果执行满足一个条件的代码块。其他条件下代码块不会执行
- if() () 必须是 【true】才能执行 if 中代码框。 【true来'源】1 直接 true 2：表达式返回值 3：直接使用变量，变量的值【转化】为布尔类型

2：三元运算符

- ? 左边 【条件】
- ? 右边 中间 满足条件的 if 语句
- ：右边 else 语句
- ： 右边  如果为条件  则是  else if 语句
- 记忆技巧  ? if  ： else 
- 嵌套逻辑 分组解决  ()

#### for 循环

1：for(key in obj){}  

- 作用 遍历对象
  2: for 
 - 应用 ；遍历数组
 - 某个语句需要重复执行多次。
 - 循环后退 与循环语句相反 若 i++ 退 i--  若 i-- 退 i++
 - 循环语句中变量  【全局变量】
 - 初始化语句必须写在循环外部
 - 循环体内语句；可以获取到每次循环变化的过程，
 - 循环体外，可以访问的左后一次执行语句时的结果。
 - i 的 变化 外部最大值 = 内部最大值+1  外部最小值 = 内部最小值-1
   for情景再现
 - 循环体中执行【函数】--> 多次调用函数，函数有返回值，这有多个返回值输出
 - 循环嵌套  里面的循环执行的总次数 = 外部循环次数 * 内部循环次数
 - 里面的循环特点，外面循环体没执行一次，里面循环执行多次
 - 动态表格实现
 - 结构复杂的数据处理
 - 多维数组
 - for 结合条件, 循环体中代码需要限制执行的时候

for 计算问题 

 - 方式：第一步：找规律
 - 第二步 根据规律写表达式
 - 第三步 找特殊（特殊条件下输出的结果）
 - 第四步: 写表达式  
 - 第五步：写完成结果的语句

for 中 break 与 continue

 - break 结束循环，即使还有好多次没有循环；也不执行了
 - continue 跳出循环体本次执行。但是不结束循环

#### 函数

1：函数定义： function 
2: 函数执行执行: 函数名()
3: 参数 

  - 形参，作用：接收实参，供方法体使用
  - 实参：为任意js 数据类型 
  - 实参如果为【定义的函数】，则这个函数是【回调函数】
  - 形参与实参一一对应 
  - 实参的个数小于等于形参的个数
  - 形参与变量区别：形参只赋值一次，变量可重复赋值
  - arguments 伪数组：接收实参 

4：方法体：

  - var定义的变量，只有方法体中变量为局部-的,其他一律全局的
  - 写语句，完成该方法的业务逻辑
  - 方法体中变量；执行完毕后就会内释放,不会再内存中保存
  - 变量局部作用域在函数执行时候形成,定义时候啥都没有

5：return 

  - 函数的【返回值】
  - 结束语句，return 下所有语句都不会被执行
  - 返回值，只有函数执行时才能【出现】
  - 应用：把函数完成一件功能；结果【告诉外界】--->外界用【变量接收】

6: 函数的调用：

  - 函数没调用一次，方法体会执行一次，执行完毕后，方法体内变量就会释放
  - 函数可以重复调用 
  - new
  - call apply bind
  - 事件触发
  - 对象调用

6.5 回调函数

  - 函数作为参数传给另一个函数 就是回调函数
  - 是否需要执行？ 需要；
    - 内置API 中 回调函数，在封装时候就触发了 
    - 自定义的，需要自己写
  - 变量为局部的
  - 回调地狱  ---> 解决方式  promise对象---> 过多.then ----> async await
  - 难点，在回调地狱中。不能情况知道执行那个函数。
  - 解决方式: 1: 打印输出  2：查看执行时传入的函数
  - 回调函数；异步的  但是代码里面的代码依然是同步的执行

7: 封装方法思路：

 - 第一步：【定作用】确定封装方法的作用是什么？
 - 第二步：【定形参】确定实现作用需要哪些【变量】材料 ---> 形参  
 - 第三步：【传实参】找到一个特殊的实参，在这个实参情，如果完成业务。况下
 - 第四步：【定值】变【变值】，把固定的值改变为可变的值
 - 第五步：【找特殊】 在特殊情况下的结果--->【写条件句写表达式】
 - 第六步：【返回结果】

8：作用域

 - 作用域分为 全局作用域和局部作用域和块级作用域【es6】
 - 作用域大的，不可以访问作用域小的变量
 - 【只有】function 函数内部的变量为【局部的】，for if 是全局的
 - 全局的变量永远不可能是私有的，不论是用var  声明的
 - 块级作用域，【不限于函数】 任何一个代码块都可以有【私有的变量】  【let】

9:作用域链【scope】

 - 作用域是 一层作用包裹另一层作用域，从而形成作用域链，通过scope完成的
 - 作用域链导致了变量的使用规则。
   - 1: 在自己的作用域中找，如果没有就去父域中找，直到找到全局域为止
 - 变量查找方式：
   -1；先看声明，再看赋值，赋值使用就近原则   
   - 注意：xxx = nnnn  不是全局的。

 10 变量提升

   - 在当前作用域中声明的变量。会将变量提升到作用域顶部。
   - 声明提升  值不提升。 【undefined】
   - 在当前域使用变量是，看当前使用时变量是否赋值   

11：this 指向

  - 1：全局下的 this 指向 window

  - 2: 函数中的this  谁调用执行谁

  - 3：事件处理函数中 this 谁触发指向谁

  - 4：对象中的this 默认指向当前对象

  - 5: 箭头函数中无this 但是如果箭头函数中出现this如何和解决

  - 6：构造函数中的this 指向构造的对象
    12: 区分this 使用时指向问题？
    第一步：看this在哪里

    - 全局   this 指向 window
    - 函数中  
      第二步：区分在什么函数中？

   - 箭头函数中  this 是 找上层【作用域】的this  【自己没有】

     -  上层作用域为全局 =====> window
     -  上层与为【function】函数 ===>安装下面步骤走

   - function函数：

   - 事件处理函数： this 指向 【触发事件的对象】 ---> 谁绑定指向谁

   - 构造函数   this 指向 构造函数[创建的对象]

   - 其他 
     第三步：看【函数后】是否有 bind() call() apply()

       - 有 以上三个函数 参一 是什么；this 指向参一对象
       - 无  ----> ,使用【谁调用指向谁规则】

   - ##### 注意 this.xx =xxx 是重新赋值；也是\是添加属性